// 16384 + 8192 = 24576

class Character
{
    field int X;
    field int Y;
    field int Width;
    field int Height;

    field int absoluteX;
    field int heightInPixels;
    field int memAddress;
    field int lastMemAddress;
    field int forceY;
    field int gravity;
    field int jumpHeight;
    field bool canJump;

    field int health;
    field int coins;

    field bool shouldRedrawObstacles;

    field int damageTimer;
    field int damageDelay;

    field bool movingLeft;

    field Array Bullets;
    field int BulletsCount;
    field int AvailableBulletsCount;
    field int currBulletIndex;
    field Bullet currBullet;

    field int bulletTimer;
    field int bulletDelay;

    field bool canShoot;
    field bool shoudlRefreshGameBullets;

    static String text;

    constructor Character new(int x2, int y2)
    {
        var int i;

        let X = x2;
        let Y = y2;
        let Width = Jeff.getWidth();
        let Height = Jeff.getHeight();

        let memAddress = Constants.getMemAddress(X, Y);
        let absoluteX = x2;
        
        let heightInPixels = Height * 16;

        let gravity = 6; // 6
        let canJump = false;
        let jumpHeight = Difficulty.getCharacterJumpHeight(); // 35

        let health = Difficulty.getCharacterHealth();
        let damageDelay = Difficulty.getCharacterDamageDelay(); // 20

        let BulletsCount = Difficulty.getCharacterBulletsCount(); // 5
        let AvailableBulletsCount = BulletsCount;
        
        do RefreshBullets();
        
        

        let bulletDelay = Difficulty.getCharacterBulletDelay();
        let bulletTimer = bulletDelay;

        let canShoot = true;

        let lastMemAddress = memAddress;

        do Draw();

        return this;
    }

    method int getX() { return X; }
    method int getY() { return Y; }
    method int getWidth() { return Width; }
    method int getHeight() { return Height; }
    method int getAbsoluteX() { return absoluteX; }
    method bool getShouldRedrawObstacles(){ return shouldRedrawObstacles; }
    method Array getBullets() { return Bullets; }
    method int getBulletsCount() { return BulletsCount; }
    method int getAvailableBulletsCount() { return AvailableBulletsCount; }
    method int getHealth() { return health; }
    method int getCoins() { return coins; }
    method bool getShoudlRefreshGameBullets() { return shoudlRefreshGameBullets;}
    method void setShoudlRefreshGameBullets(int b) { let shoudlRefreshGameBullets = b; return;}

    method void setShouldRedrawObstacles(bool s) { let shouldRedrawObstacles = s; return; }
    method void setMovingLeft(bool b) { let movingLeft = b; return; }

    method void incrementAbsoluteX(int inc) { let absoluteX = absoluteX + inc; return; }
    method void addCoin() { let coins = coins + 1; return; }
    method void addLife() 
    {
        if ((health + 1) < Difficulty.getCharacterHealthLimit())
        {
            let health = health + 1;
            do printHealth();
        }
        
        return;
    }


    //// TIMERS
    method void CheckTimers()
	{
        if (bulletTimer < 1)
        {
            let canShoot = true;
            let bulletTimer = bulletDelay;
        }

		return;
	}

	method void DecrementTimers()
	{
        let bulletTimer = bulletTimer - 1;

		return;
	}
    

    //// CHECKS


    

    method void printHealth()
    {
        do Output.moveCursor(0, 18);
        let text = ": ";
        do Output.printString(text);
        do Output.printInt(health);

        return;
    }

    method void printCoins()
    {
        do Output.moveCursor(0, 26);
        let text = ": ";
        do Output.printString(text);
        do Output.printInt(coins);

        return;
    }

    method void printAmmo()
    {
        do Output.moveCursor(0, 34);
        let text = ": ";
        do Output.printString(text);
        do Output.printInt(AvailableBulletsCount);

        return;
    }

    method bool IsCollidedWithFinish(Finish finish)
    {
        return finish.IsCollidedWithCharacter(X, Y, Width, Height);
    }

    method void DoEnemyAction(Enemy enemy, Array map, int mapWidth, int mapHeight, int worldOffset)
    {
        do enemy.DoActions(worldOffset, X, Y);

        return;
    }

    method void CheckCollisionWithEnemy(Enemy enemy)
    {
        if (enemy.CheckCollisionWithCharacter(X, Y, Width, heightInPixels))
        {
            do Respawn();
            do TakeDamage();
        }

        return;
    }

    method void CheckCollisionWithBullet(Bullet bullet)
    {
        if (bullet.CheckCollisionWithEntity(X, Y, Width, heightInPixels))
        {
            do Respawn();
            do TakeDamage();
        }

        return;
    }

    method void CheckCollisionWithCollectable(Collectable collectable)
    {
        var int result;
        var int bCount;

        let result = collectable.CheckCollisionWithCharacter(X, Y, Width, heightInPixels);

        if (result = 0)
        {
            do addCoin();
            do ForceDraw();
        }
        else { if (result = 1)
        {
            if (Difficulty.getCanPickUpHealth())
            {
                do addLife();
                do ForceDraw();
            }
        }
        else { if (result = 2)
        {
            if (Difficulty.getCanPickUpAmmo())
            {
                let bCount = BulletsCount;
                do ClearAllBullets();

                if ((AvailableBulletsCount + Difficulty.getAmmoCount()) > Difficulty.getCharacterBulletLimit())
                {
                    let AvailableBulletsCount = Difficulty.getCharacterBulletLimit();
                }
                else
                {
                    let AvailableBulletsCount = AvailableBulletsCount + Difficulty.getAmmoCount();
                }
                
                let BulletsCount = AvailableBulletsCount;
                if (~(bCount = 0))
                {
                    do Bullets.dispose();
                }
                do RefreshBullets();
                do ForceDraw();
            }
        }}}

        return;
    }

    method void ClearAllBullets()
    {
        var int i;
        var Bullet bullet;

        while (i < BulletsCount)
        {
            let bullet = Bullets[i];
            do bullet.Clear();
            do bullet.Reset();
            let i = i + 1;
        }

        return;
    }

    method void RefreshBullets()
    {
        var int i;

        let shoudlRefreshGameBullets = true;

        if (~(BulletsCount = 0))
        {
            let Bullets = Array.new(BulletsCount);
            while (i < BulletsCount)
            {
                let Bullets[i] = Bullet.new();
                let i = i + 1;
            }
            let currBullet = Bullets[currBulletIndex];

            do printAmmo();
        }

        return;
    }

    method void RedrawPlatforms(int worldOffset)
    {
        do Collision.RedrawPlatforms(X, Y, Width, heightInPixels, worldOffset);

        return;
    }

    //// PLATFORM COLLISION
    method bool CheckCollisionWithPlatformRight(int worldOffset)
    {
        return Collision.CheckAnyPlatformCollisionRight(X, Y, Width, Height, worldOffset);
    }

    method bool CheckCollisionWithPlatformLeft(int worldOffset)
    {
        return Collision.CheckAnyPlatformCollisionLeft(X, Y, Width, Height, worldOffset);
    }

    //// OBSTACLE COLLISION
    method void CheckCollisionWithObstacles()
    {
        var int i;
        var bool result;

        let result = Collision.IsCollidedAnyObstacle(absoluteX, Y, Width, Height);

        if (result)
        {
            let shouldRedrawObstacles = true;

            do TakeDamage();
            do Respawn();
        }

        if (damageTimer > 0)
        {
            let damageTimer = damageTimer - 1;
        }

        return;
    }
    
    //// MOVEMENT
    method void MoveLeft()
    {
        if (X > 0)
        {
            let lastMemAddress = memAddress;
            let memAddress = memAddress - 1;
            do Clear();
            let X = X - 1;
            let absoluteX = absoluteX - 1;
            do Draw(); 
        }

        return;
    }

    method void MoveRight()
    {
        if((X + Width) < 32)
        {
            let lastMemAddress = memAddress;
            let memAddress = memAddress + 1;
            do Clear();
            let X = X + 1;
            let absoluteX = absoluteX + 1;
            do Draw(); 
        }


        return;

    }

    method void Jump()
    {
        if (canJump)
        {
            let forceY = forceY - jumpHeight;
        }

        return;
    }

    method void CheckGravity(int worldOffset)
    {
        var int i;
        var Platform platform;
        var Section section;
        var bool is_on_platform;

        let canJump = Collision.IsOnAnyPlatform(X, Y, Width, Height, forceY, worldOffset);

        if (canJump)
        {
            let Y = Collision.getPlatformY() - 16;

            let forceY = 0;

            let lastMemAddress = memAddress;
            let memAddress = Constants.getMemAddress(X, Y);
            do Clear();
            do Draw();
        }
        // padanje
        else
        {
            if (Y > 219)
            {
                //do Respawn();

                // take damage
            }

            let forceY = forceY + gravity;      

               
        }

        let Y = Y + forceY;

        
        let lastMemAddress = memAddress;
        let memAddress = Constants.getMemAddress(X, Y);
        do Clear();
        do Draw();
        
        return;
    }


    method void Respawn()
    {
        let Y = 100;

        if (X - 10 < 1)
        {
            let X = X + 5;
            let absoluteX = absoluteX + 5;
        }
        else
        {
            let X = X - 10;
            let absoluteX = absoluteX - 10;
        }
        
        return;
    }

    method void TakeDamage()
    {
        // dont take damage if already taken
        if (damageTimer < 1)
        {
            //do Output.printString("oof");
            //do Output.println();

            let health = health - 1;
            let damageTimer = damageDelay;

            do printHealth();
        }

        return;
    }

    method void Shoot(int worldOffset)
    {
        var int bulletX;
        var int bulletY;

        if (~(AvailableBulletsCount = 0))
        {
            if (movingLeft)
            {
                let bulletX = X - 1;
            }
            else
            {
                let bulletX = X + Width;
            }
            let bulletY = Y - Constants.getBlockHeight();

            if (canShoot)
            {
                if (currBullet.IsAvailable())
                {
                    do currBullet.Shoot(bulletX, bulletY, movingLeft, worldOffset);

                    let currBulletIndex = currBulletIndex + 1;

                    if (currBulletIndex > (BulletsCount - 1))
                    {
                        let currBulletIndex = 0;
                    }

                    let currBullet = Bullets[currBulletIndex];

                    if (~Difficulty.getCharacterHasInfiniteBullets())
                    {
                        let AvailableBulletsCount = AvailableBulletsCount - 1;
                    }
                }

                let canShoot = false;
            }

            do printAmmo();
        }

        //do Output.printInt(AvailableBulletsCount);

        return;
    }

    method void CheckBullets(int worldOffset)
    {
        var int i;
        var Bullet bullet;

        while (i < BulletsCount)
        {
            let bullet = Bullets[i];
            do bullet.CheckBullet(worldOffset);
            let i = i + 1;
        }

        return;
    }

    //// DRAW/CLEAR
    method void Clear()
	{
		if (~(memAddress = lastMemAddress))
		{
			if (Difficulty.getDifficulty() = 4)
            {
                do InsaneJeff.DrawFrame(lastMemAddress, false, movingLeft, X, Y);
            }
            else
            {
                do Jeff.DrawFrame(lastMemAddress, false, movingLeft, X, Y);
            }
		}

		return;
	}

    method void Draw()
    {
		if (~(memAddress = lastMemAddress))
		{
            if (Difficulty.getDifficulty() = 4)
            {
                do InsaneJeff.DrawFrame(memAddress, true, movingLeft, X, Y);
            }
            else
            {
                do Jeff.DrawFrame(memAddress, true, movingLeft, X, Y);
            }
		}
		
		return;
    }

    method void ForceDraw()
    {
        if (Difficulty.getDifficulty() = 4)
        {
            do InsaneJeff.DrawFrame(memAddress, true, movingLeft, X, Y);
        }
        else
        {
            do Jeff.DrawFrame(memAddress, true, movingLeft, X, Y);
        }
		
		return;
    }
}