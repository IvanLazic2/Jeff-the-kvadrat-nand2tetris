// 16384 + 8192 = 24576

class Character
{
    field int X;
    field int Y;
    field int Width;
    field int Height;

    field int absoluteX;
    field int heightInPixels;
    field int memAddress;
    field int lastMemAddress;
    field int forceY;
    field int gravity;
    field int jumpHeight;
    field bool canJump;

    field int health;
    field int coins;

    field bool shouldRedrawObstacles;

    field int damageTimer;
    field int damageDelay;

    field bool movingLeft;

    field Array Bullets;
    field int BulletsCount;
    field int AvailableBulletsCount;
    field int currBulletIndex;
    field Bullet currBullet;

    field int bulletTimer;
    field int bulletDelay;

    field bool canShoot;

    field bool shoudlRefreshGameBullets;

    constructor Character new(int x2, int y2)
    {
        var int i;

        let X = x2;
        let Y = y2;
        let Width = Jeff.getWidth();
        let Height = Jeff.getHeight();

        let memAddress = Constants.getMemAddress(X, Y);
        let absoluteX = x2;
        
        let heightInPixels = Height * 16;

        let gravity = 6; // 6
        let canJump = false;
        let jumpHeight = Difficulty.getCharacterJumpHeight(); // 35

        let health = Difficulty.getCharacterHealth();
        let damageDelay = Difficulty.getCharacterDamageDelay(); // 20

        let BulletsCount = Difficulty.getCharacterBulletsCount(); // 5
        let AvailableBulletsCount = BulletsCount;
        
        do RefreshBullets();
        
        

        let bulletDelay = 10;
        let bulletTimer = bulletDelay;

        let canShoot = true;

        let lastMemAddress = memAddress;

        do Draw(memAddress, true);

        return this;
    }

    method int get_x() { return X; }

    method int get_y() { return Y; }

    method int getWidth() { return Width; }
    method int getHeight() { return Height; }

    method int get_absolute_x() { return absoluteX; }

    method bool getShouldRedrawObstacles(){ return shouldRedrawObstacles; }

    method Array getBullets() { return Bullets; }

    method int getBulletsCount() { return BulletsCount; }
    method int getAvailableBulletsCount() { return AvailableBulletsCount; }

    method int getHealth() { return health; }
    method int getCoins() { return coins; }

    method bool getShoudlRefreshGameBullets() { return shoudlRefreshGameBullets;}
    method void setShoudlRefreshGameBullets(int b) { let shoudlRefreshGameBullets = b; return;}

    method void addCoin() { let coins = coins + 1; return; }
    method void addLife() { let health = health + 1; return; }

    method void set_x(int x2)
    {
        let X = x2;
        return;
    }

    method void set_y(int y2)
    {
        let Y = y2;
        return;
    }

    method void set_absolute_x(int abs_x)
    {
        let absoluteX = abs_x;
        return;
    }

    method void setShouldRedrawObstacles(bool s)
    {
        let shouldRedrawObstacles = s;
        return;
    }

    method void increment_absolute_x(int inc)
    {
        let absoluteX = absoluteX + inc;
        return;
    }

    method void set_draw_character_left(bool b)
    {
        let movingLeft = b;
        return;
    }



    
    method void CheckTimers()
	{
        if (bulletTimer < 1)
        {
            let canShoot = true;
            let bulletTimer = bulletDelay;
        }

		return;
	}

	method void DecrementTimers()
	{
        let bulletTimer = bulletTimer - 1;

		return;
	}
    



    method void DoEnemyAction(Enemy enemy, Array map, int mapWidth, int mapHeight, int worldOffset)
    {
        do enemy.DoActions(worldOffset, X, Y);

        return;
    }

    method void CheckCollisionWithEnemy(Enemy enemy)
    {
        if (enemy.CheckCollisionWithCharacter(X, Y, Width, heightInPixels))
        {
            do Respawn();
            do TakeDamage();
        }

        return;
    }

    method void CheckCollisionWithBullet(Bullet bullet)
    {
        if (bullet.CheckCollisionWithEntity(X, Y, Width, heightInPixels))
        {
            do Respawn();
            do TakeDamage();
        }

        return;
    }

    method void CheckCollisionWithCollectable(Collectable collectable)
    {
        var int result;
        var int bCount;

        let result = collectable.CheckCollisionWithCharacter(X, Y, Width, heightInPixels);

        if (result = 0)
        {
            do addCoin();
            do Draw(memAddress, true);
        }
        else { if (result = 1)
        {
            do addLife();
            do Draw(memAddress, true);
        }
        else { if (result = 2)
        {
            if (Difficulty.getCanPickUpAmmo())
            {
                let bCount = BulletsCount;
                do ClearAllBullets();
                let AvailableBulletsCount = AvailableBulletsCount + Difficulty.getAmmoCount();
                let BulletsCount = AvailableBulletsCount;
                if (~(bCount = 0))
                {
                    do Bullets.dispose();
                }
                do RefreshBullets();
            }
        }}}

        return;
    }

    method void ClearAllBullets()
    {
        var int i;
        var Bullet bullet;

        while (i < BulletsCount)
        {
            let bullet = Bullets[i];
            do bullet.Clear();
            do bullet.Reset();
            let i = i + 1;
        }

        return;
    }

    method void RefreshBullets()
    {
        var int i;

        let shoudlRefreshGameBullets = true;

        if (~(BulletsCount = 0))
        {
            let Bullets = Array.new(BulletsCount);
            while (i < BulletsCount)
            {
                let Bullets[i] = Bullet.new();
                let i = i + 1;
            }
            let currBullet = Bullets[currBulletIndex];
        }

        return;
    }



    method void RedrawPlatforms(int worldOffset)
    {
        do Collision.RedrawPlatforms(X, Y, Width, heightInPixels, worldOffset);

        return;
    }

    //// PLATFORM COLLISION
    method bool CheckCollisionWithPlatformRight(int worldOffset)
    {
        return Collision.CheckAnyPlatformCollisionRight(X, Y, Width, Height, worldOffset);
    }

    method bool CheckCollisionWithPlatformLeft(int worldOffset)
    {
        return Collision.CheckAnyPlatformCollisionLeft(X, Y, Width, Height, worldOffset);
    }

    //// OBSTACLE COLLISION
    method void CheckCollisionWithObstacles()
    {
        var int i;
        var bool result;

        let result = Collision.IsCollidedAnyObstacle(absoluteX, Y, Width, Height);

        if (result)
        {
            let shouldRedrawObstacles = true;

            do TakeDamage();
            do Respawn();
        }

        if (damageTimer > 0)
        {
            let damageTimer = damageTimer - 1;
        }

        return;
    }
    
    //// MOVEMENT
    method void MoveLeft()
    {
        if (X > 0)
        {
            let lastMemAddress = memAddress;

            let X = X - 1;
            let absoluteX = absoluteX - 1;
            let memAddress = memAddress - 1;

            do Clear();
            do Draw(memAddress, true); 
        }

        return;
    }

    method void MoveRight()
    {
        if((X + Width) < 32)
        {
            let lastMemAddress = memAddress;

            let X = X + 1;
            let absoluteX = absoluteX + 1;
            let memAddress = memAddress + 1;

            do Clear();
            do Draw(memAddress, true); 
        }


        return;

    }

    method void Jump()
    {
        if (canJump)
        {
            let forceY = forceY - jumpHeight;
        }

        return;
    }

    method void CheckGravity(int worldOffset)
    {
        var int i;
        var Platform platform;
        var Section section;
        var bool is_on_platform;

        let lastMemAddress = memAddress;

        let canJump = Collision.IsOnAnyPlatform(X, Y, Width, Height, forceY, worldOffset);

        if (canJump)
        {
            let Y = Collision.getPlatformY() - 16;

            let forceY = 0;
            let memAddress = Constants.getMemAddress(X, Y);

            do Clear();
            do Draw(memAddress, true);
        }
        // padanje
        else
        {
            if (Y > 219)
            {
                //do Respawn();

                // take damage
            }

            let forceY = forceY + gravity;      

               
        }


        let Y = Y + forceY;
        let memAddress = Constants.getMemAddress(X, Y);

        do Clear();
        do Draw(memAddress, true);
        

        return;
    }


    method void Respawn()
    {
        let Y = 100;

        if (X - 10 < 1)
        {
            let X = X + 5;
            let absoluteX = absoluteX + 5;
        }
        else
        {
            let X = X - 10;
            let absoluteX = absoluteX - 10;
        }
        
        return;
    }

    method void TakeDamage()
    {
        // dont take damage if already taken
        if (damageTimer < 1)
        {
            do Output.printString("oof");
            do Output.println();

            let health = health - 1;
            let damageTimer = damageDelay;
        }

        return;
    }

    method void Shoot(int worldOffset)
    {
        var int bulletX;
        var int bulletY;

        if (~(AvailableBulletsCount = 0))
        {
            if (movingLeft)
            {
                let bulletX = X - 1;
            }
            else
            {
                let bulletX = X + Width;
            }
            let bulletY = Y - Constants.getBlockHeight();

            if (canShoot)
            {
                if (currBullet.IsAvailable())
                {
                    do currBullet.Shoot(bulletX, bulletY, movingLeft, worldOffset);

                    let currBulletIndex = currBulletIndex + 1;

                    if (currBulletIndex > (BulletsCount - 1))
                    {
                        let currBulletIndex = 0;
                    }

                    let currBullet = Bullets[currBulletIndex];

                    if (~Difficulty.getCharacterHasInfiniteBullets())
                    {
                        let AvailableBulletsCount = AvailableBulletsCount - 1;
                    }
                }

                let canShoot = false;
            }
        }

        //do Output.printInt(AvailableBulletsCount);

        return;
    }

    method void CheckBullets(int worldOffset)
    {
        var int i;
        var Bullet bullet;

        while (i < BulletsCount)
        {
            let bullet = Bullets[i];
            do bullet.CheckBullet(worldOffset);
            let i = i + 1;
        }

        return;
    }

    //// DRAW/CLEAR
    method void Clear()
	{
		do Draw(lastMemAddress, false);

		return;
	}

    method void Draw(int m, bool display)
    {
		if (~(memAddress = lastMemAddress))
		{
			do Jeff.DrawFrame(m, display, movingLeft, X, Y);
		}
		
		return;
    }
}