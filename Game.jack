//https://www.youtube.com/watch?v=Ouza_4SsbLc
//https://codepen.io/rickyjw/pen/qrjmdz
//https://editor.p5js.org/Coulomb1/sketches/ajYsnHRW2
//https://www.coursera.org/lecture/nand2tetris2/unit-3-10-graphics-optimization-hHNmi
//https://classes.engineering.wustl.edu/cse365/demo_program.php
//https://arieljannai.gitlab.io/Nand2TetrisBitmapEditor/
//https://github.com/ErikUmble/nand2tetris/tree/main/DinoAdventure





// IDEJA: sortirat platforme po x koordinati
// IDEJA2: brojac koji broji kolko ih je izaslo iz ekrana. kolko ih je izaslo tolko mogu stvorit novih tako da starima promijenim koordinate.
//         ako nijedna nije izasla iz ekrana, a treba se pokazat novi, sam stvorim novu platformu




class Game
{
    field int direction;
    field Character character;
    field int screen_width;
    field int move_area_width;
    field int screen_middle;
    field int left_border;
    field int right_border;

    field int platforms_num;
    field int obstacles_num;
    field int sections_num;
    field int section_width;

    field Array platforms;
    field Array obstacles;
    field Array sections;

    field Section curr_section;
    field Section last_section;
    field int curr_section_index;
    field int last_section_index;
    field Array curr_platforms;
    field int curr_platforms_num;

    field Array div4lookup;

    field Level3 level;
    field int level_width;

    field Enemy enemy;



    field Array curr_obstacles;
    field int curr_obstacles_num;




    field int game_delay;

    field int timer3;
    field int timer6;
    field int timer100;

    field Array Map;
    field int MapWidth;
    field int MapHeight;

    field int WorldOffset;


    constructor Game new()
    {
        var int i;

        let direction = 0;

        let screen_width = 32;
        let move_area_width = 5; // 5
        let screen_middle = 16;
        let left_border = screen_middle - move_area_width;
        let right_border = screen_middle + move_area_width;

        let level = Level3.new();
        let Map = level.get_map();
        let MapWidth = level.get_map_width();
        let MapHeight = level.get_map_height();

        let level_width = level.get_level_width();
        let character = level.get_character();

        let platforms_num = level.get_platforms_num();
        let platforms = level.get_platforms();

        let sections_num = level.get_sections_num();
        let section_width = level.get_section_width();
        let sections = level.get_sections();

        let obstacles_num = level.get_obstacles_num();
        let obstacles = level.get_obstacles();

        let div4lookup = Array.new(level_width);
        let i = 0;
        while (i < level_width)
        {
            let div4lookup[i] = i / 4;
            let i = i + 1;
        }

        let last_section = sections[get_curr_section_index()];



        let game_delay = 20;

        let timer3 = 3;
        let timer6 = 6;
        let timer100 = 100;

        let WorldOffset = 0;





        let enemy = Enemy.new(0, 200, 2);
        //do enemy.Draw(true, false);
        
        

        return this;
    }

    method int get_curr_section_index()
    {
        return div4lookup[character.get_absolute_x()];
    }

    method void start()
    {
        var char key;
        var bool exit;
        var int i;
        var Platform platform;


        let exit = false;

        //do Screen.drawLine(0, 255-80, 511, 255-80);

        while (~exit)
        {
            

            let key = Keyboard.keyPressed();

            if (key = 0)
            {
                let direction = 0;
            }
            else { if (key = 131)
            {
                do character.Jump();
            }
            else { if (key = 81) 
            {
                let exit = true;
            }
            else { if (key = 130) 
            {
                let direction = 1;
            }
            else { if (key = 132) 
            {
                let direction = 2;
            }}}}}
            


            do UpdateCurrentSection();

            do Move();
            do Sys.wait(game_delay);
            
            //do curr_section.Draw();
            do character.RedrawPlatforms(Map, MapWidth, MapHeight, WorldOffset);
            

            //do enemy.Draw(true, false);
            //do enemy.MoveRight();
            //do enemy.MoveLeft();

            //do enemy.check_gravity2(Map, MapWidth, MapHeight);
            //do enemy.Jump();
            //do enemy.MoveRight();
            

            do CheckTimers();





            let last_section_index = get_curr_section_index();

            do DecrementTimers();
        }

        return;
    }

    method void CheckTimers()
    {
        if (timer6 < 1)
        {
            //do RedrawLastSection();
            do RedrawAllObstacles();

            let timer6 = 6;
        }

        if (timer100 < 1)
        {
            //do Screen.drawLine(0, 255-80, 511, 255-80);

            let timer100 = 100;
        }

        
        do enemy.CheckTimers();

        return;
    }

    method void DecrementTimers()
    {
        let timer3 = timer3 - 1;
        let timer6 = timer6 - 1;
        let timer100 = timer100 - 1;

        do enemy.DecrementTimers();

        return;
    }

    method void UpdateCurrentSection()
    {   
        let curr_section_index = get_curr_section_index();

        let curr_section = sections[curr_section_index];
        
        let curr_platforms = curr_section.get_platforms();
        let curr_platforms_num = curr_section.get_platforms_num();

        let curr_obstacles = curr_section.get_obstacles();
        let curr_obstacles_num = curr_section.get_obstacles_num();

        return;
    }

    method void RedrawLastSection()
    {
        var int index;
        var Section section;

        if (character.get_should_draw_last_obstacle())
        {
            let index = div4lookup[character.get_last_abs_x()];
            let section = sections[index];
            do section.Draw();
            do character.set_should_draw_last_obstacle(false);
        }

        return;
    }

    method void RedrawAllObstacles()
    {
        var Obstacle obstacle;
        var int i;

        if (character.get_should_draw_last_obstacle())
        {
            while (i < obstacles_num)
            {
                let obstacle = obstacles[i];

                do obstacle.Draw();

                let i = i + 1;
            }
            do character.set_should_draw_last_obstacle(false);
        }

        return;
    }


    method void ScrollLeft()
    {
        var int i;
        var Platform platform;
        var Obstacle obstacle;

        let WorldOffset = WorldOffset + 1;
        do character.increment_absolute_x(1);

        while (i < obstacles_num)
        {
            let obstacle = obstacles[i];
            do obstacle.ClearScrollLeft();

            let i = i + 1;
        }

        let i = 0;
        while (i < platforms_num)
        {
            let platform = platforms[i];
            do platform.ClearScrollLeft();

            let i = i + 1;
        }

        let i = 0;
        while (i < obstacles_num)
        {
            let obstacle = obstacles[i];
            do obstacle.DrawScrollLeft();

            let i = i + 1;
        }

        let i = 0;
        while (i < platforms_num)
        {
            let platform = platforms[i];
            do platform.DrawScrollLeft();

            let i = i + 1;
        }

        return;
    }

    method void ScrollRight()
    {
        var int i;
        var Platform platform;
        var Obstacle obstacle;

        let WorldOffset = WorldOffset - 1;
        do character.increment_absolute_x(-1);

        while (i < obstacles_num)
        {
            let obstacle = obstacles[i];
            do obstacle.ClearScrollRight();

            let i = i + 1;
        }

        let i = 0;
        while (i < platforms_num)
        {
            let platform = platforms[i];
            do platform.ClearScrollRight();

            let i = i + 1;
        }

        let i = 0;
        while (i < obstacles_num)
        {
            let obstacle = obstacles[i];
            do obstacle.DrawScrollRight();

            let i = i + 1;
        }

        let i = 0;
        while (i < platforms_num)
        {
            let platform = platforms[i];
            do platform.DrawScrollRight();

            let i = i + 1;
        }

        return;
    }

    method void Move()
    {
        var int x;
        var int abs_x;
        
        let x = character.get_x();
        let abs_x = character.get_absolute_x();

        do character.check_gravity2(Map, MapWidth, MapHeight);
        do character.check_collision_obstacles2(Map, MapWidth, MapHeight);

        if (direction = 1) 
        {
            do character.set_draw_character_left(true);

            if (~character.check_left_collision_platforms2(Map, MapWidth, MapHeight))
            {
                // nesto s apsolutnom vrijednosti izmedju x i pocetka mape?
                if (abs_x - screen_middle + move_area_width > 0)
                {
                    if (x > left_border)
                    {
                        do character.MoveLeft();
                    }
                    else
                    {
                        do ScrollRight();
                    }
                }
                else
                {
                    do character.MoveLeft();
                }
            }
        }
        if (direction = 2)
        {
            do character.set_draw_character_left(false);

            if (~character.check_right_collision_platforms2(Map, MapWidth, MapHeight))
            {
                if (abs_x + screen_middle - move_area_width < level_width)
                {
                    if (x < right_border)
                    {   
                        do character.MoveRight();
                    }
                    else
                    {
                        do ScrollLeft();
                    }
                }
                else
                {
                    do character.MoveRight();
                }
            }
        }
        
        return;
    }
}
    